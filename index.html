<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Essay Grading Model</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
    }
    table, th, td {
      border: 1px solid #ddd;
    }
    th, td {
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f4f4f4;
    }
    .section {
      margin-bottom: 20px;
    }
    #predict_section {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Essay Grading Model</h1>

  <div class="section">
    <h2>Training Data</h2>
    <table id="data_table">
      <tr>
        <th>Essay</th>
        <th>Main Grade</th>
        <th>Subgrade 1</th>
        <th>Subgrade 2</th>
        <!-- Add more subgrades here as needed -->
      </tr>
      <tr>
        <td>This is the first essay.</td>
        <td>85</td>
        <td>90</td>
        <td>80</td>
      </tr>
      <tr>
        <td>This is the second essay.</td>
        <td>75</td>
        <td>70</td>
        <td>65</td>
      </tr>
      <!-- Add more training data rows here -->
    </table>
    <button onclick="trainModel()">Train Models</button>
    <div id="output"></div>
  </div>

  <div id="predict_section" class="section">
    <h2>Predict Grades</h2>
    <textarea id="new_essay_input" rows="4" cols="50" placeholder="Enter an essay to predict the grade..."></textarea><br>
    <button onclick="predictGrade()">Predict</button>
    <div id="predicted_grade_output"></div>
  </div>

  <script>
    const models = {
      mainGrade: null,
      subGrades: {},
    };

    async function trainModel() {
      const learningRate = 0.005;

      function preprocessText(essays) {
        const tokenizedInputs = essays.map((essay) => {
          const words = essay.trim().split(/\s+/);
          const vector = new Array(1200).fill(0);
          for (let word of words) {
            const index = Math.min(word.length, 1199);
            vector[index] += 1;
          }
          return vector;
        });
        return tf.tensor2d(tokenizedInputs);
      }

      const mainGradeInputEssays = [];
      const mainGradeTargets = [];
      const subGradeData = {};
      const rows = document.querySelectorAll("#data_table tr:not(:first-child)");

      rows.forEach((row) => {
        const essay = row.querySelector("td:nth-child(1)").innerText.trim();
        const grade = parseInt(row.querySelector("td:nth-child(2)").innerText.trim(), 10);
        if (essay && !isNaN(grade)) {
          mainGradeInputEssays.push(essay);
          mainGradeTargets.push(grade);
        }

        const subgradeCells = row.querySelectorAll("td:nth-child(n+3):not(:last-child)");
        subgradeCells.forEach((cell, index) => {
          if (!subGradeData[index]) subGradeData[index] = { inputs: [], targets: [] };
          const subgrade = parseInt(cell.innerText.trim(), 10);
          if (!isNaN(subgrade)) {
            subGradeData[index].inputs.push(essay);
            subGradeData[index].targets.push(subgrade);
          }
        });
      });

      const mainGradeInputTrainTensor = preprocessText(mainGradeInputEssays);
      const mainGradeTargetTrainTensor = tf.tensor1d(mainGradeTargets);

      models.mainGrade = tf.sequential();
      models.mainGrade.add(tf.layers.dense({ inputShape: [1200], units: 1 }));
      const mainGradeOptimizer = tf.train.adam(learningRate);
      models.mainGrade.compile({
        optimizer: mainGradeOptimizer,
        loss: "meanSquaredError",
      });

      await models.mainGrade.fit(mainGradeInputTrainTensor, mainGradeTargetTrainTensor, {
        epochs: 10,
        verbose: 0,
      });
      console.log("Main Grade Model Trained");

      for (const [subgradeIndex, data] of Object.entries(subGradeData)) {
        const subgradeInputTrainTensor = preprocessText(data.inputs);
        const subgradeTargetTrainTensor = tf.tensor1d(data.targets);

        models.subGrades[subgradeIndex] = tf.sequential();
        models.subGrades[subgradeIndex].add(tf.layers.dense({ inputShape: [1200], units: 1 }));
        const subGradeOptimizer = tf.train.adam(learningRate);
        models.subGrades[subgradeIndex].compile({
          optimizer: subGradeOptimizer,
          loss: "meanSquaredError",
        });

        await models.subGrades[subgradeIndex].fit(subgradeInputTrainTensor, subgradeTargetTrainTensor, {
          epochs: 10,
          verbose: 0,
        });
        console.log(`Subgrade Model ${subgradeIndex} Trained`);
      }

      console.log("All Models Trained!");
      document.getElementById("output").innerText = "All Models Trained!";
      document.getElementById("predict_section").style.display = "block";
    }

    async function predictGrade() {
      function preprocessText(essays) {
        const tokenizedInputs = essays.map((essay) => {
          const words = essay.trim().split(/\s+/);
          const vector = new Array(1200).fill(0);
          for (let word of words) {
            const index = Math.min(word.length, 1199);
            vector[index] += 1;
          }
          return vector;
        });
        return tf.tensor2d(tokenizedInputs);
      }

      const essayInput = document.getElementById("new_essay_input").value.trim();
      if (!essayInput) {
        alert("Please enter an essay to predict the grade.");
        return;
      }

      const essayTensor = preprocessText([essayInput]);

      if (!models.mainGrade) {
        alert("The main grade model is not trained yet. Please train the model.");
        return;
      }
      const mainGradePrediction = await models.mainGrade.predict(essayTensor).data();
      const predictedMainGrade = mainGradePrediction[0];

      const subGradePredictions = [];
      for (const [subgradeIndex, model] of Object.entries(models.subGrades)) {
        const subgradePrediction = await model.predict(essayTensor).data();
        subGradePredictions.push({ subgradeIndex, grade: subgradePrediction[0] });
      }

      const predictionOutput = `
        Predicted Main Grade: ${predictedMainGrade.toFixed(2)}
        ${subGradePredictions
          .map(
            (sub) =>
              `Predicted Subgrade ${parseInt(sub.subgradeIndex) + 1}: ${sub.grade.toFixed(2)}`
          )
          .join("\n")}
      `;
      document.getElementById("predicted_grade_output").innerText = predictionOutput;
    }
  </script>
</body>
</html>
