<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Essay Grader Demo</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.4.0"></script>
</head>

<body>
    <h1>AI Essay Grader</h1>
    <h2>Revised Solution Trials (Prompt 2)</h2>
    <div id="app"></div>
    <div class="w3-black">
        <div class="w3-container w3-green w3-center" id="loading_bar" style="width: 0%">
            <p id="percentage_label">0%</p>
            <p id="time_label"></p>
        </div>
    </div>

    <div id="wrapper" align="center">
        <table align="center" cellspacing="2" cellpadding="5" id="data_table" border="1">
            <thead>
                <tr>
                    <th>Essay</th>
                    <th>Main Grade</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="data_table_body">
                <tr id="row1">
                    <td id="essay_row1">This is a terrible essay</td>
                    <td id="grade_row1">1</td>
                    <td>
                        <input type="button" value="Remove Essay" class="delete" onclick="delete_row('1')" />
                    </td>
                </tr>
                <tr id="row2">
                    <td id="essay_row2">This is an excellent essay.</td>
                    <td id="grade_row2">4</td>
                    <td>
                        <input type="button" value="Remove Essay" class="delete" onclick="delete_row('2')" />
                    </td>
                </tr>
                <tr>
                    <td><input type="text" id="new_name" /></td>
                    <td><input type="text" id="new_country" /></td>
                    <td><input type="button" class="add" onclick="add_row();" value="Add Essay" /></td>
                </tr>
            </tbody>
        </table>
        <input type="button" value="Add Subgrade Column" onclick="addSubgradeColumn()" />
        <input type="button" value="Remove Subgrade Column" onclick="removeSubgradeColumn()" />
    </div>

    <h3>Playground/Demo</h3>
    <h4>Please copy and paste your graded essays (straight from Docs, Word, etc) - no rubric is required!</h4>
    <input type="button" id="train_model" value="Start Playground Model" onclick="trainModel()" />
    <div id="output"></div>

    <div id="predict_section" style="display: none; margin-top: 20px">
        <h3>Enter a new essay to predict its grade:</h3>
        <textarea id="new_essay_input" rows="4" cols="50" placeholder="Type your essay here..."></textarea>
        <br />
        <input type="button" id="predict_grade" value="Predict Grade" onclick="predictGrade()" />
        <div id="predicted_grade_output"></div>
    </div>

    <script>
        var finalModel;
        var subgradeModels = {};  // Store subgrade models by their column name

        // Function to add a subgrade column
        function addSubgradeColumn() {
            const table = document.getElementById("data_table");
            const header = table.querySelector("thead tr");
            const subgradeName = prompt("Enter name for the new subgrade:");
            if (subgradeName) {
                const subgradeIndex = header.cells.length - 1;
                const newHeaderCell = document.createElement("th");
                newHeaderCell.textContent = subgradeName;
                header.appendChild(newHeaderCell);

                // Add corresponding subgrade data cell for each row
                const rows = document.querySelectorAll("#data_table_body tr");
                rows.forEach((row) => {
                    const subgradeCell = document.createElement("td");
                    subgradeCell.innerHTML = `<input type="text" id="subgrade_input_${row.id}_${subgradeName}" />`;
                    row.appendChild(subgradeCell);
                });
            }
        }

        // Function to remove the last subgrade column
        function removeSubgradeColumn() {
            const table = document.getElementById("data_table");
            const header = table.querySelector("thead tr");
            const subgradeCells = table.querySelectorAll("tbody tr td:last-child");
            if (header.cells.length > 3) {
                header.deleteCell(header.cells.length - 1);
                subgradeCells.forEach((cell) => {
                    cell.remove();
                });
            } else {
                alert("Cannot remove the last column.");
            }
        }

        // Function for training the model (with subgrades)
        async function trainModel() {
            const learningRate = 0.005;
            var percentageDone = 0;
            var totalTimeTaken = 0;
            var startTime = Date.now() / 1000;
            var currentTime = 0;

            function preprocessText(essays) {
                const tokenizedInputs = essays.map((essay) => {
                    const words = essay.trim().split(/\s+/);
                    const vector = new Array(1200).fill(0);
                    for (let word of words) {
                        const index = Math.min(word.length, 1199);
                        vector[index] += 1;
                    }
                    return vector;
                });
                return tf.tensor2d(tokenizedInputs);
            }

            const mainGradeInputEssays = [];
            const mainGradeTargets = [];
            const subgradeInputs = {};

            const rows = document.querySelectorAll("#data_table tr:not(:first-child)");
            rows.forEach((row) => {
                const essay = row.querySelector("td:nth-child(1)").innerText.trim();
                const grade = parseInt(row.querySelector("td:nth-child(2)").innerText.trim(), 10);
                if (essay && !isNaN(grade)) {
                    mainGradeInputEssays.push(essay);
                    mainGradeTargets.push(grade);

                    // Collect subgrades
                    const subgradeCells = row.querySelectorAll("td:nth-child(n+3)");
                    subgradeCells.forEach((cell, index) => {
                        const subgradeName = document.querySelector("#data_table th:nth-child(" + (index + 3) + ")").textContent;
                        const subgradeValue = parseInt(cell.querySelector("input").value, 10);
                        if (!isNaN(subgradeValue)) {
                            if (!subgradeInputs[subgradeName]) {
                                subgradeInputs[subgradeName] = [];
                            }
                            subgradeInputs[subgradeName].push(subgradeValue);
                        }
                    });
                }
            });

            const mainGradeInputTrainTensor = preprocessText(mainGradeInputEssays);
            const mainGradeTargetTrainTensor = tf.tensor1d(mainGradeTargets);

            // Create and train a model for main grade predictions
            finalModel = tf.sequential();
            finalModel.add(tf.layers.dense({ inputShape: [1200], units: 1 }));
            finalModel.compile({ optimizer: tf.train.adam(learningRate), loss: "meanSquaredError" });

            // Train the model for main grade
            let mainGradeEpoch = 0;
            while (mainGradeEpoch < 3000) {
                mainGradeEpoch += 1;
                await finalModel.fit(mainGradeInputTrainTensor, mainGradeTargetTrainTensor, { epochs: 1, verbose: 0 });

                // Log progress every 10 epochs
                if (mainGradeEpoch % 10 === 0) {
                    percentageDone += 0.3333333333;
                    currentTime = Date.now() / 1000;
                    totalTimeTaken = currentTime - startTime;
                    updateProgress(percentageDone, totalTimeTaken);
                }
            }

            // Create a model for each subgrade
            for (let subgradeName in subgradeInputs) {
                const subgradeTensor = tf.tensor1d(subgradeInputs[subgradeName]);
                const subgradeModel = tf.sequential();
                subgradeModel.add(tf.layers.dense({ inputShape: [1200], units: 1 }));
                subgradeModel.compile({ optimizer: tf.train.adam(learningRate), loss: "meanSquaredError" });
                subgradeModels[subgradeName] = subgradeModel;

                // Train each subgrade model
                await subgradeModel.fit(mainGradeInputTrainTensor, subgradeTensor, { epochs: 3000, verbose: 0 });
            }

            alert("Training Complete!");
        }

        function updateProgress(percentage, time) {
            const percentageElem = document.getElementById("percentage_label");
            const timeElem = document.getElementById("time_label");
            percentageElem.textContent = percentage.toFixed(0) + "%";
            timeElem.textContent = `Time elapsed: ${time.toFixed(2)}s`;
            document.getElementById("loading_bar").style.width = `${percentage}%`;
        }

        // Predict grade for new essay with subgrades
        async function predictGrade() {
            const essay = document.getElementById("new_essay_input").value.trim();
            if (essay) {
                const essayTensor = tf.tensor2d([essay.split(/\s+/).map(word => word.length)]);
                const gradePrediction = await finalModel.predict(essayTensor).data();

                let subgradePredictions = {};
                for (let subgradeName in subgradeModels) {
                    const subgradePrediction = await subgradeModels[subgradeName].predict(essayTensor).data();
                    subgradePredictions[subgradeName] = subgradePrediction[0];
                }

                document.getElementById("predicted_grade_output").innerHTML = `Predicted Grade: ${gradePrediction[0]}<br>Subgrade Predictions: ${JSON.stringify(subgradePredictions)}`;
            }
        }
    </script>
</body>
</html>
  
