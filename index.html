<!DOCTYPE html>
<html>
  <head>
    <title>AI Essay Grader Demo</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.4.0"></script>
  </head>
  <body>
    <h1>AI Essay Grader</h1>
    <h2>Revised Solution Trials (Prompt 2)</h2>
    <div id="app"></div>

    <div class="w3-black">
      <div class="w3-container w3-green w3-center" id="loading_bar" style="width: 0%">
        <p id="percentage_label">0%</p>
        <p id="time_label"></p>
        <p id="training_label"></p>
      </div>
    </div>

    <h1></h1>
    <div id="wrapper" align="center">
      <table align="center" cellspacing="2" cellpadding="5" id="data_table" border="1">
        <tr id="header_row">
          <th>Essay</th>
          <th>Main Grade</th>
          <th id="actions_header">Actions</th>
        </tr>
        <tr id="row1">
          <td id="essay_row1"><input type="text" value="This is a terrible essay" /></td>
          <td id="grade_row1"><input type="text" value="1" /></td>
          <td id="actions_row1">
            <input type="button" value="Save" class="save" onclick="save_row('1')" />
            <input type="button" value="Remove Essay" class="delete" onclick="delete_row('1')" />
          </td>
        </tr>
        <tr id="row2">
          <td id="essay_row2"><input type="text" value="This is an excellent essay." /></td>
          <td id="grade_row2"><input type="text" value="4" /></td>
          <td id="actions_row2">
            <input type="button" value="Save" class="save" onclick="save_row('2')" />
            <input type="button" value="Remove Essay" class="delete" onclick="delete_row('2')" />
          </td>
        </tr>
        <tr id="add_row">
          <td><input type="text" id="new_name" /></td>
          <td><input type="text" id="new_country" /></td>
          <td id="add_actions">
            <input type="button" class="add" onclick="add_row();" value="Add Essay" />
            <input type="button" class="add_subgrade" onclick="add_subgrade();" value="Add Subgrade" />
          </td>
        </tr>
      </table>
      <h3>Playground/Demo</h3>
      <h4>Please copy and paste your graded essays (straight from Docs, Word, etc) - no rubric is required!</h4>
      <input type="button" id="train_model" value="Start Playground Model" onclick="trainModel()" />
      <div id="output"></div>
    </div>

    <div id="predict_section" style="display: none; margin-top: 20px">
      <h3>Enter a new essay to predict its grade:</h3>
      <textarea id="new_essay_input" rows="4" cols="50" placeholder="Type your essay here..."></textarea>
      <br />
      <input type="button" id="predict_grade" value="Predict Grade" onclick="predictGrade()" />
      <div id="predicted_grade_output"></div>
    </div>

    <script>
      var finalModel;
      var subgradeModels = {};

      function updateProgress(percentage, totalTimeTaken, trainingLabel) {
        percentage = Math.max(0, Math.min(100, percentage));
        percentage = percentage.toFixed(2);
        const loadingBar = document.getElementById("loading_bar");
        const percentageLabel = document.getElementById("percentage_label");
        const timeLabel = document.getElementById("time_label");
        const trainingLabelElement = document.getElementById("training_label");

        loadingBar.style.width = percentage + "%";
        percentageLabel.textContent = percentage + "%";
        trainingLabelElement.textContent = trainingLabel;

        if (percentage > 0) {
          const elapsedTime = totalTimeTaken;
          const expectedTotalTime = elapsedTime / (percentage / 100);
          const remainingTime = expectedTotalTime - elapsedTime;
          const formatTime = (timeInSeconds) => {
            const minutes = Math.floor(timeInSeconds / 60);
            const seconds = Math.floor(timeInSeconds % 60);
            return `${minutes} minutes - ${seconds.toString().padStart(2, "0")} seconds`;
          };
          const timeTaken = formatTime(elapsedTime);
          const totalTime = formatTime(expectedTotalTime);
          timeLabel.textContent = `${timeTaken} / ${totalTime}`;
        }
      }

      async function predictGrade() {
        function preprocessText(essays) {
          const tokenizedInputs = essays.map((essay) => {
            const words = essay.trim().split(/\s+/);
            const vector = new Array(1200).fill(0);
            for (let word of words) {
              const index = Math.min(word.length, 1199);
              vector[index] += 1;
            }
            return vector;
          });
          return tf.tensor2d(tokenizedInputs);
        }

        const essayInput = document.getElementById("new_essay_input").value.trim();
        if (!essayInput) {
          alert("Please enter an essay to predict the grade.");
          return;
        }

        const essayTensor = preprocessText([essayInput]);

        if (!finalModel) {
          alert("The model is not trained yet. Please train the model before predicting.");
          return;
        }

        const prediction = await finalModel.predict(essayTensor).data();
        const predictedGrade = prediction[0];
        console.log("predicted unrounded", prediction[0]);
        document.getElementById("predicted_grade_output").innerText = `Predicted Grade: ${Math.round(predictedGrade)}`;

        const subgradePredictions = {};
        for (const subgrade in subgradeModels) {
          const subgradePrediction = await subgradeModels[subgrade].predict(essayTensor).data();
          subgradePredictions[subgrade] = subgradePrediction[0];
          console.log("subgrade unrounded", subgradePrediction[0]);
        }

        const subgradePredictionText = Object.keys(subgradePredictions).map(subgrade => `${subgrade}: ${Math.round(subgradePredictions[subgrade])}`).join(', ');
        document.getElementById("predicted_grade_output").innerText += `\nSubgrade Predictions: ${subgradePredictionText}`;
      }

      async function trainModel() {
        const learningRate = 0.005;
        var percentageDone = 0;
        var totalTimeTaken = 0;
        var startTime = Date.now() / 1000;
        var currentTime = 0;

        function preprocessText(essays) {
          const tokenizedInputs = essays.map((essay) => {
            const words = essay.trim().split(/\s+/);
            const vector = new Array(1200).fill(0);
            for (let word of words) {
              const index = Math.min(word.length, 1199);
              vector[index] += 1;
            }
            return vector;
          });
          return tf.tensor2d(tokenizedInputs);
        }

        const mainGradeInputEssays = [];
        const mainGradeTargets = [];
        const subgradeInputEssays = {};
        const subgradeTargets = {};

        const rows = document.querySelectorAll("#data_table tr:not(:first-child):not(:last-child)");
        rows.forEach((row) => {
          const essay = row.querySelector("td:nth-child(1) input").value.trim();
          const grade = parseFloat(row.querySelector("td:nth-child(2) input").value.trim());
          if (essay && !isNaN(grade)) {
            mainGradeInputEssays.push(essay);
            mainGradeTargets.push(grade);
          }

          // Collect subgrade data
          const subgradeCells = row.querySelectorAll("td:nth-child(3) input");
          subgradeCells.forEach((cell, index) => {
            const subgradeName = `subgrade_${index + 1}`;
            const subgradeValue = parseFloat(cell.value);
            if (!subgradeInputEssays[subgradeName]) {
              subgradeInputEssays[subgradeName] = [];
              subgradeTargets[subgradeName] = [];
            }
            subgradeInputEssays[subgradeName].push(essay);
            subgradeTargets[subgradeName].push(subgradeValue);
          });
        });

        const mainGradeTensorInputs = preprocessText(mainGradeInputEssays);
        const mainGradeTensorTargets = tf.tensor2d(mainGradeTargets, [mainGradeTargets.length, 1]);

        // Create the main model for predicting the main grade
        const mainGradeModel = tf.sequential();
        mainGradeModel.add(tf.layers.dense({ inputShape: [1200], units: 256, activation: "relu" }));
        mainGradeModel.add(tf.layers.dense({ units: 1 }));

        mainGradeModel.compile({ optimizer: tf.train.adam(learningRate), loss: "meanSquaredError" });

        // Train the main model
        await mainGradeModel.fit(mainGradeTensorInputs, mainGradeTensorTargets, {
          epochs: 30,
          batchSize: 16,
          callbacks: {
            onEpochEnd: async (epoch, logs) => {
              currentTime = Date.now() / 1000;
              totalTimeTaken = currentTime - startTime;
              percentageDone = ((epoch + 1) / 30) * 100;
              updateProgress(percentageDone, totalTimeTaken, `Training Model for Main Grade`);
            }
          }
        });

        finalModel = mainGradeModel;
        updateProgress(100, totalTimeTaken, `Model Trained!`);

        // Train subgrade models
        for (const subgradeName in subgradeInputEssays) {
          const subgradeInputTensor = preprocessText(subgradeInputEssays[subgradeName]);
          const subgradeTargetTensor = tf.tensor2d(subgradeTargets[subgradeName], [subgradeTargets[subgradeName].length, 1]);

          const subgradeModel = tf.sequential();
          subgradeModel.add(tf.layers.dense({ inputShape: [1200], units: 256, activation: "relu" }));
          subgradeModel.add(tf.layers.dense({ units: 1 }));

          subgradeModel.compile({ optimizer: tf.train.adam(learningRate), loss: "meanSquaredError" });

          await subgradeModel.fit(subgradeInputTensor, subgradeTargetTensor, {
            epochs: 30,
            batchSize: 16,
            callbacks: {
              onEpochEnd: async (epoch, logs) => {
                currentTime = Date.now() / 1000;
                totalTimeTaken = currentTime - startTime;
                percentageDone = ((epoch + 1) / 30) * 100;
                updateProgress(percentageDone, totalTimeTaken, `Training Model for Subgrade ${subgradeName}`);
              }
            }
          });

          subgradeModels[subgradeName] = subgradeModel;
        }

        // Enable the prediction section
        document.getElementById("predict_section").style.display = "block";
      }

      function save_row(rowNumber) {
        // Save logic
      }

      function delete_row(rowNumber) {
        // Delete logic
      }

      function add_row() {
        // Add logic
      }

      function add_subgrade() {
        // Add subgrade logic
      }
    </script>
  </body>
</html>
